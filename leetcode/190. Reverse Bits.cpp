/*
* 題目：LeetCode 190. Reverse Bits
 * 連結：https://leetcode.com/problems/reverse-bits/
 *
 * 【Embedded 對應】
 * - 位元重排：常見於端序/位序轉換、外設資料位元顛倒；用遮罩/移位分組交換更接近硬體思維。
 *
 * 敘述：將 32 位無號整數的位元順序反轉。
 *
 * 解法 A（位元遮罩分組交換；高速、常數時間）：
 *  - 先交換奇偶位，再交換每 2 位、每 4 位、每 8 位、每 16 位。
 * 複雜度：時間 O(1)、空間 O(1)
 */

#include <cstdint>
using namespace std;

class Solution {
public:
    uint32_t reverseBits(uint32_t n) {
        n = ((n >> 1)  & 0x55555555u) | ((n & 0x55555555u) << 1);
        n = ((n >> 2)  & 0x33333333u) | ((n & 0x33333333u) << 2);
        n = ((n >> 4)  & 0x0F0F0F0Fu) | ((n & 0x0F0F0F0Fu) << 4);
        n = ((n >> 8)  & 0x00FF00FFu) | ((n & 0x00FF00FFu) << 8);
        n = (n >> 16) | (n << 16);
        return n;
    }
};

/* 解法 B（迴圈 32 次；簡單但略慢）
class Solution {
public:
    uint32_t reverseBits(uint32_t n) {
        uint32_t res = 0;
        for (int i = 0; i < 32; ++i) {
            res = (res << 1) | (n & 1u);
            n >>= 1;
        }
        return res;
    }
};
*/


// 題目背景 (LeetCode 190)
//
// 給你一個 32 位元的數字 n
//
// 要把它的 二進位表示 從左到右反過來
//
// 例子 (只舉 8 位方便看)：
//
// n = 00001101  (十進位 13)
// 結果要變成：10110000
//
// 程式架構
// uint32_t reverseBits(uint32_t n) {
//     uint32_t res = 0;                // 答案桶子，先是空的
//     for (int i = 0; i < 32; ++i) {   // 做 32 次（因為有 32 個 bit）
//         res = (res << 1) | (n & 1u); // Step 1: 放球
//         n >>= 1;                     // Step 2: 下一顆球
//     }
//     return res;
// }
//
// 心法比喻 🏀
//
// 想像 n 是一排 32 顆球（每顆球只能是 0 或 1）
//
// 我們要把這些球 倒著放 到另一個桶子 res 裡
//
// 每一回合做的事
// Step 1: 取球
// n & 1u
//
//
// 這句會拿到 n 的 最右邊的球
//
// 如果最後一位是 1 → 拿到 1
//
// 如果最後一位是 0 → 拿到 0
//
// Step 2: 給 res 空位
// res << 1
//
//
// 把 res 裡的球 往左移一格，右邊空出一格，準備放新球。
//
// Step 3: 把球放進 res
// (res << 1) | (n & 1u)
//
//
// | 是「或」，就像是把剛拿到的球丟進空格
//
// 所以 res 多了一顆新球在最右邊
//
// Step 4: 推進 n
// n >>= 1;
//
//
// 把 n 的球列 整排往右推一格，這樣下一次就能取到「下一顆球」。
//
// 範例走一遍 (用 8 位，n=13=00001101)
//
// 初始：
//
// n   = 00001101
// res = 00000000
//
//
// 迴圈第 1 次：
//
// n & 1 = 1 → 拿到最後一顆球「1」
//
// res << 1 = 00000000，再放 1 → res = 00000001
//
// n >>= 1 = 00000110
//
// 迴圈第 2 次：
//
// n & 1 = 0 → 拿到球「0」
//
// res << 1 = 00000010，再放 0 → res = 00000010
//
// n >>= 1 = 00000011
//
// 迴圈第 3 次：
//
// n & 1 = 1
//
// res << 1 = 00000100，再放 1 → res = 00000101
//
// n >>= 1 = 00000001
//
// 迴圈第 4 次：
//
// n & 1 = 1
//
// res << 1 = 00001010，再放 1 → res = 00001011
//
// n >>= 1 = 00000000
//
// 剩下回合：n 已經變成全 0，後面只會塞 0
// 最後 res = 10110000 ✅ 完成！
//
// 一句話總結 🧠
//
// 每次做：
//
// 從 n 拿最右邊一顆球 (n & 1)
//
// res 左移空位 (res << 1)
//
// 把球放進去 (|)
//
// 把 n 右移 (>>) 換下一顆球

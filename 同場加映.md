å¤ªå¥½äº†ï¼Œé€™å››é¡Œå°±æ˜¯ Storage/Infra çš„ç²¾è¯ ğŸ”§
æˆ‘çµ¦ä½ ã€Œå¯ç›´æ¥ç”¨çš„ C++11 ç¨‹å¼ç¢¼ + å¿ƒæ³•ã€ä»¥åŠå…©é¡Œç³»çµ±è¨­è¨ˆçš„ç­”é¡Œæ¡†æ¶ã€‚å…¨éƒ¨æ˜¯ Markdownï¼Œç›´æ¥è²¼åˆ° Notion å³å¯ã€‚

---

# 1) æ‰‹å¯« Token Bucket Rate Limiterï¼ˆC++11ï¼Œmutex + chronoï¼‰

**å¿ƒæ³•**

* ä»¤ `capacity`=æ¡¶æœ€å¤§å®¹é‡ã€`rate`=æ¯ç§’è£œå……çš„ token æ•¸ã€‚
* æ¯æ¬¡æ“ä½œå…ˆæŒ‰ç¶“éæ™‚é–“ `dt` å›å¡«ï¼š`tokens = min(capacity, tokens + rate * dt)`ï¼Œå†å˜—è©¦æ‰£é™¤ã€‚
* åœ¨ user-space ç”¨ `mutex` ä¿è­·è‡¨ç•Œå€ï¼›åœ¨ MCU/ISR æœƒç”¨ **disable IRQ** é”åˆ°åŒæ¨£æ•ˆæœã€‚

```cpp
#include <mutex>
#include <chrono>
#include <algorithm>

class TokenBucket {
    const double capacity_;                    // æ¡¶æœ€å¤§å®¹é‡
    const double rate_per_sec_;                // æ¯ç§’è£œå…… token é€Ÿåº¦
    double tokens_;                            // ç•¶å‰ token æ•¸ï¼ˆå¯ç”¨ double åšè¿‘ä¼¼ï¼‰
    std::chrono::steady_clock::time_point last_refill_;
    std::mutex mtx_;

    void refill_locked(std::chrono::steady_clock::time_point now) {
        using namespace std::chrono;
        const double dt = duration<double>(now - last_refill_).count(); // ç§’
        if (dt > 0) {
            tokens_ = std::min(capacity_, tokens_ + rate_per_sec_ * dt);
            last_refill_ = now;
        }
    }

public:
    TokenBucket(double capacity, double rate_per_sec)
        : capacity_(capacity), rate_per_sec_(rate_per_sec),
          tokens_(capacity), last_refill_(std::chrono::steady_clock::now()) {}

    // å˜—è©¦å–å¾— n å€‹ tokenï¼ŒæˆåŠŸå› trueï¼›å¤±æ•—å› falseï¼ˆä¸é˜»å¡ï¼‰
    bool try_acquire(int n = 1) {
        auto now = std::chrono::steady_clock::now();
        std::lock_guard<std::mutex> lk(mtx_);
        refill_locked(now);
        if (tokens_ + 1e-9 >= n) { // å®¹å¿å¾®å°æµ®é»èª¤å·®
            tokens_ -= n;
            return true;
        }
        return false;
    }

    // è§€å¯Ÿï¼šç›®å‰ token å¤§ç´„å¤šå°‘ï¼ˆåƒ…ä¾›ç›£æ§ï¼‰
    double approx_tokens() {
        auto now = std::chrono::steady_clock::now();
        std::lock_guard<std::mutex> lk(mtx_);
        refill_locked(now);
        return tokens_;
    }
};
```

> é¢è©¦å»¶ä¼¸ï¼š
>
> 1. ç”¨ã€Œæ•´æ•¸å¾®å–®ä½ã€é¿å…æµ®é»èª¤å·®ï¼ˆä¾‹å¦‚æŠŠ 1 token = 1000 micro-tokensï¼‰ã€‚
> 2. é˜»å¡ç‰ˆ `acquire(n)` å¯ç”¨ `condition_variable` å–šé†’ã€‚
> 3. åœ¨ ISR/MCUï¼šæ›´æ–° `tokens_` å‰å¾Œ **disable/enable IRQ** ä»£æ›¿ mutexã€‚

---

# 2) FIFO Circular Queueï¼ˆarray + head/tail æŒ‡æ¨™ï¼‰

**å¿ƒæ³•**

* ä½¿ç”¨å›ºå®šå¤§å°çš„é™£åˆ— + å…©å€‹ç´¢å¼•ï¼š`head`ï¼ˆè®€ï¼‰/`tail`ï¼ˆå¯«ï¼‰ã€‚
* åˆ¤æ–·ï¼š`full` ç•¶ä¸‹ä¸€å€‹ tail æœƒæ’ä¸Š headï¼›`empty` ç•¶ head==tailã€‚
* è‹¥å®¹é‡æ˜¯ 2 çš„å†ªï¼Œå¯ç”¨ä½å…ƒé®ç½©å–ä»£ `%` å–é¤˜æ•¸ã€‚

## 2.1 å–®åŸ·è¡Œç·’ï¼å–®æ ¸ï¼ˆæ•™å­¸ç‰ˆï¼Œæœ€ç›´è§€ï¼‰

```cpp
#include <array>
#include <cstddef>
#include <cstdint>

template <typename T, std::size_t N>
class RingBuffer {
    static_assert(N > 1, "N must be > 1");
    std::array<T, N> buf_{};
    std::size_t head_ = 0; // è®€
    std::size_t tail_ = 0; // å¯«

    std::size_t inc(std::size_t x) const { return (x + 1) % N; }

public:
    bool empty() const { return head_ == tail_; }
    bool full()  const { return inc(tail_) == head_; }
    std::size_t size() const { return (tail_ + N - head_) % N; }
    std::size_t capacity() const { return N - 1; } // é ç•™ä¸€æ ¼å€åˆ†æ»¿/ç©º

    bool push(const T& v) {
        if (full()) return false;
        buf_[tail_] = v;
        tail_ = inc(tail_);
        return true;
    }

    bool pop(T& out) {
        if (empty()) return false;
        out = buf_[head_];
        head_ = inc(head_);
        return true;
    }
};
```

## 2.2 SPSCï¼ˆSingle-Producer/Single-Consumerï¼‰ç‰ˆï¼ˆé–å…ã€å¸¸è¦‹æ–¼ UARTï¼‰

```cpp
#include <array>
#include <atomic>
#include <cstddef>

template <typename T, std::size_t N>
class RingSPSC {
    static_assert((N & (N - 1)) == 0, "N must be power-of-two");
    std::array<T, N> buf_{};
    std::atomic<std::size_t> head_{0}; // åªæœ‰ consumer æ›´æ–°
    std::atomic<std::size_t> tail_{0}; // åªæœ‰ producer æ›´æ–°
    static constexpr std::size_t mask_ = N - 1;

public:
    bool empty() const { return head_.load(std::memory_order_acquire) == tail_.load(std::memory_order_acquire); }
    bool full()  const { return ((tail_.load(std::memory_order_acquire) + 1) & mask_) == head_.load(std::memory_order_acquire); }

    bool push(const T& v) { // producer ç·šç¨‹
        auto t = tail_.load(std::memory_order_relaxed);
        auto h = head_.load(std::memory_order_acquire);
        if (((t + 1) & mask_) == h) return false; // full
        buf_[t & mask_] = v;
        tail_.store((t + 1) & mask_, std::memory_order_release);
        return true;
    }

    bool pop(T& out) { // consumer ç·šç¨‹
        auto h = head_.load(std::memory_order_relaxed);
        auto t = tail_.load(std::memory_order_acquire);
        if (h == t) return false; // empty
        out = buf_[h & mask_];
        head_.store((h + 1) & mask_, std::memory_order_release);
        return true;
    }
};
```

> MCU å°æ‡‰ï¼šUART RX ISR å¾€ç’°å½¢ä½‡åˆ— `push`ï¼Œä¸»å¾ªç’°åœ¨éä¸­æ–·æƒ…å¢ƒ `pop`ã€‚
> åœ¨ ISR ä¸­ã€Œæ›´æ–° head/tailã€çš„é‚£æ®µå³æ˜¯ **critical section**ï¼Œå¸¸è¦‹åšæ³•æ˜¯ **çŸ­æš«é—œä¸­æ–·**ã€‚

---

# 3) ç³»çµ±è¨­è¨ˆé¡Œï¼šè¨­è¨ˆã€Œç°¡å–® Rate Limiterã€ï¼ˆToken Bucketï¼‰

**ä¸€åˆ†é˜å£æ¢**

> æˆ‘ç”¨ **Token Bucket**ã€‚æ¯å€‹ keyï¼ˆuser/API/IPï¼‰ç¶­è­· `capacity/rate/tokens/last_ts`ã€‚
> æœ¬åœ°åŸ·è¡Œç·’å…ˆåš **æœ¬åœ°æ¡¶** å¿«é€Ÿåˆ¤æ–·ï¼›éœ€è¦å…¨åŸŸä¸€è‡´æ€§æ™‚ï¼Œå†æŠŠè¨ˆæ•¸è½åˆ°å…±äº«å­˜å„²ï¼ˆå¦‚ Redis/è‡ªå®¶æœå‹™ï¼‰ï¼Œä»¥ **1 ç§’æˆ– 100ms ç²’åº¦**åˆä½µä¸Šå ±ï¼Œé¿å…ç†±é»ã€‚æ”¯æ´ **é™æµç­‰ç´šã€çªç™¼ï¼ˆburstï¼‰**ï¼Œä»¥åŠ **429 + Retry-After** å›æ‡‰ç­–ç•¥ã€‚

**è¨­è¨ˆè¦é»**

* **è³‡æ–™æ¨¡å‹**ï¼š
  `state = {capacity, rate, tokens, last_ts}`ï¼ˆå¯åŠ  `burst`, `max_delay`ï¼‰ã€‚
* **è£œæ¡¶ç­–ç•¥**ï¼š

  * pull-basedï¼šè«‹æ±‚åˆ°ä¾†æ™‚è¨ˆç®— `dt` è£œæ¡¶ï¼ˆæœ€ç°¡å–®ï¼‰ã€‚
  * push-basedï¼šèƒŒæ™¯ timer æ¯ 100ms/1s è£œä¸€æ¬¡ï¼ˆæ›´ç©©å®šï¼Œä¾¿æ–¼è§€å¯Ÿï¼‰ã€‚
* **éƒ¨ç½²æ‹“æ’²**ï¼š

  * å–®æ©Ÿï¼šin-proc mapï¼ˆæœ€å¿«ï¼‰ã€‚
  * åˆ†æ•£å¼ï¼š

    * **Local fast-path + global reconcile**ï¼ˆå»ºè­°ï¼‰ï¼šæœ¬æ©Ÿå…ˆåˆ¤å®šï¼Œé€±æœŸä¸Šå ±ã€‚
    * ç´”é›†ä¸­å¼ï¼ˆRedis/Limiter æœå‹™ï¼‰ï¼šä¸€è‡´æ€§å¥½ä½†å»¶é²/æˆæœ¬é«˜ã€‚
* **ç²¾åº¦/æŠ–å‹•**ï¼š

  * `timer tick` è¶Šå°è¶Šå¹³æ»‘ï¼ˆ100ms å¸¸è¦‹ï¼‰ï¼Œä½†å¿ƒè·³æˆæœ¬æ›´é«˜ã€‚
* **å…¬å¹³æ€§**ï¼š

  * æ¯ key ç¨ç«‹æ¡¶ï¼Œæˆ–åˆ†å±¤ï¼ˆtenant â†’ ip â†’ userï¼‰ã€‚
* **å›æ‡‰**ï¼š

  * è¶…é‡ â†’ 429ï¼Œçµ¦ `Retry-After` æˆ– `X-RateLimit-Remaining/Reset`ã€‚
* **I/O block / IRQ é—œè¯**ï¼š

  * åœ¨æ ¸å¿ƒ/é©…å‹•æƒ…å¢ƒï¼Œè£œæ¡¶/æ‰£æ¡¶æ˜¯è‡¨ç•Œå€ï¼Œéœ€è¦ **disable IRQ** æˆ–ç”¨é–ï¼›
  * åœ¨ä½¿ç”¨è€…æ…‹æœå‹™ï¼Œç”¨ `mutex/atomic` ä¿è­·å³å¯ã€‚
* **ç›£æ§**ï¼šæ‹’çµ•ç‡ã€çªç™¼é•·åº¦ã€bucket åˆ©ç”¨ç‡ã€p95 æˆæ¬Šå»¶é²ã€‚

---

# 4) ç°¡æ˜“åˆ†æ•£å¼ Log Storageï¼ˆè¨­è¨ˆæ¡†æ¶ï¼‰

**ç›®æ¨™**

* é«˜åå append-only å¯«å…¥ã€æŒ‰ topic/partition å­˜æ”¾ã€å¯è¨­å®šä¿ç•™/å£“ç¸®ã€æ•…éšœä¸ä¸Ÿè³‡æ–™ã€‚

**é—œéµå…ƒä»¶**

1. **Brokers / Ingest**ï¼šæ¥æ”¶å¯«å…¥ï¼ŒæŒ‰ key åš **partitionï¼ˆconsistent hashingï¼‰**ã€‚
2. **Storage Nodes**ï¼šæ¯å€‹ partition æ˜¯ä¸€æ¢ **append-only segment log**ï¼ˆæª”æ¡ˆåˆ‡æ®µï¼‰ï¼Œé… **ç¨€ç–ç´¢å¼•**ï¼ˆoffsetâ†’fileposï¼‰ã€‚
3. **Metadata Serviceï¼ˆå¼·ä¸€è‡´ï¼‰**ï¼šTopic/Partition/ISR åˆ—è¡¨ã€mappingã€leaseã€‚

  * ç”¨ **Raft** æˆ– etcd/ZKï¼›**Leader election** ç®¡ç† partition çš„ leaderã€‚
4. **Replicas**ï¼š`replication factor = 3` å¸¸è¦‹ï¼›å¯«å…¥è·¯å¾‘ `leader â†’ followers`ã€‚

  * **ACK ç­‰ç´š**ï¼š`acks=1`ï¼ˆleader è½ç›¤ï¼‰ï¼`acks=all`ï¼ˆISR éƒ½æ”¶ï¼‰ã€‚
5. **Retention/Compaction**ï¼š

  * æ™‚é–“/å®¹é‡ä¿ç•™ï¼ˆä¾‹å¦‚ 7 å¤©æˆ– 500GBï¼‰ï¼Œsegment é”é–¾å€¼è¼ªè½‰ï¼›
  * key-based compaction ä¿ç•™æœ€æ–°ç‰ˆæœ¬ï¼ˆé¡ä¼¼ Kafka log compactionï¼‰ã€‚

**å¯«å…¥ I/O è·¯å¾‘ï¼ˆæ¦‚å¿µï¼‰**
App â†’ Brokerï¼ˆbatch èšåˆï¼‰ â†’ OS page cache â†’ `append segment` â†’ é€±æœŸ `fsync`ï¼ˆæˆ– `O_DIRECT` è¦–å ´æ™¯ï¼‰

* **æ‰¹æ¬¡ + é †åºå¯«å…¥** å……åˆ†åˆ©ç”¨ SSD/HDDã€‚
* å¾Œå°åš **segment åˆä½µ/åˆªèˆŠ**ï¼Œé¿å…éš¨æ©Ÿå¯«ã€‚

**å®¹éŒ¯èˆ‡æ¢å¾©**

* å¤±å» leader â†’ Metadata è§¸ç™¼é‡æ–°é¸èˆ‰ï¼›client é€é metadata é‡æ–°è·¯ç”±ã€‚
* follower è½å¾Œ â†’ æ ¹æ“šé«˜æ°´ä½ï¼ˆHWï¼‰è¿½ä¸Šï¼›è¶…éè¿½è¶•çª—å£ â†’ é‡æ–°å¿«ç…§ã€‚

**èˆ‡ã€Œè¨ˆç®—æ©Ÿçµ„ç¹” / I/O block / BSPã€çš„å°æ‡‰**

* **è¨ˆç®—æ©Ÿçµ„ç¹”**ï¼šå–„ç”¨ã€Œé †åºå¯« + page cache + å¤§ blockã€ï¼Œæ¸›å°‘ seekã€‚
* **I/O block**ï¼šsegment/ç´¢å¼•ä»¥ **å¡Šå°é½Š**ï¼ˆ4KB/16KBï¼‰æå‡ååã€‚
* **BSP**ï¼šåœ¨é‚Šç·£/è¨­å‚™ç«¯ï¼Œdriver/æ–‡ä»¶ç³»çµ±å±¤æä¾›å¡Šè¨­å‚™æŠ½è±¡ï¼›é›²ç«¯å´å°æ‡‰ç‚º storage driver/FS/RAID å±¤ã€‚

**é¢è©¦å£æ¢ï¼ˆ30 ç§’ï¼‰**

> æˆ‘ç”¨ **topic/partition** æ¶æ§‹ï¼›æ¯å€‹ partition æ˜¯ append-only æ®µæª” + ç¨€ç–ç´¢å¼•ã€‚
> **Metadataï¼ˆRaftï¼‰** ç®¡ leader/å‰¯æœ¬ï¼›å¯«å…¥èµ° leaderï¼ŒåŒæ­¥åˆ° ISRã€‚
> ä»¥ **é †åºå¯« + æ‰¹æ¬¡** å–é«˜ååï¼Œé€±æœŸ fsyncï¼›ä¿ç•™èˆ‡å£“ç¸®ç”¨ segment è¼ªè½‰èˆ‡ compactionã€‚
> å¤±æ•—åˆ‡æ›é é¸èˆ‰èˆ‡é«˜æ°´ä½æ¢å¾©ï¼›è·¯ç”±é  metadata æ˜ å°„ã€‚

---

## å»ºè­°ç·´æ³•ï¼ˆä»Šå¤©å°±èƒ½å‹•æ‰‹ï¼‰

* **Coding**ï¼šæŠŠ `TokenBucket` åŒ…ä¸€å±¤ `RateLimiter`ï¼Œæä¾› `allow(user_id, n)`ï¼›ç”¨å¤šåŸ·è¡Œç·’å£“æ¸¬ï¼ˆ`std::thread`ï¼‰çœ‹æ‹’çµ•ç‡ã€‚
* **FIFO**ï¼šæŠŠ `RingSPSC<uint8_t, 256>` é€£åŒä¸€å€‹ã€Œæ¨¡æ“¬ UART ISRï¼šæ¯ 1ms pushã€èˆ‡ã€Œä¸»å¾ªç’°ï¼špoll popã€åšæˆ demoã€‚
* **ç³»çµ±è¨­è¨ˆ**ï¼šå£è¿°ä¸€ç‰ˆã€Œå–®æ©Ÿ â†’ å¤šæ©Ÿ â†’ è·¨æ©Ÿæˆ¿ã€æ¼”é€²ï¼Œæº–å‚™ä¸€å¼µ 5Ã—5 å–æ¨è¡¨ï¼ˆå»¶é²ã€ååã€ä¸€è‡´æ€§ã€æˆæœ¬ã€å·¥ç¨‹è¤‡é›œåº¦ï¼‰ã€‚
* **Log Storage**ï¼šç•«å‡º 5 å€‹æ–¹å¡Šï¼ˆClient/Broker/Storage/Metadata/Monitorï¼‰ï¼Œåœ¨ç´™ä¸Šæ¨™å‡ºå¯«å…¥è·¯å¾‘èˆ‡å¤±æ•—åˆ‡æ›æ™‚åºã€‚

å¦‚æœä½ è¦ï¼Œæˆ‘å¯ä»¥æŠŠä¸Šè¿°å…©å€‹ C++ é¡Œï¼ˆTokenBucketã€RingSPSCï¼‰æ‰“åŒ…æˆ**å–®ä¸€æª”æ¡ˆ**ã€åŠ ä¸Šç°¡çŸ­ `main()` æ¸¬è©¦æ¨¡æ¿ï¼Œç¬¦åˆä½  CLion çš„ç¿’æ…£ï¼ˆå«è¨»è§£ï¼‰ã€‚

太好了，這四題就是 Storage/Infra 的精華 🔧
我給你「可直接用的 C++11 程式碼 + 心法」以及兩題系統設計的答題框架。全部是 Markdown，直接貼到 Notion 即可。

---

# 1) 手寫 Token Bucket Rate Limiter（C++11，mutex + chrono）

**心法**

* 令 `capacity`=桶最大容量、`rate`=每秒補充的 token 數。
* 每次操作先按經過時間 `dt` 回填：`tokens = min(capacity, tokens + rate * dt)`，再嘗試扣除。
* 在 user-space 用 `mutex` 保護臨界區；在 MCU/ISR 會用 **disable IRQ** 達到同樣效果。

```cpp
#include <mutex>
#include <chrono>
#include <algorithm>

class TokenBucket {
    const double capacity_;                    // 桶最大容量
    const double rate_per_sec_;                // 每秒補充 token 速度
    double tokens_;                            // 當前 token 數（可用 double 做近似）
    std::chrono::steady_clock::time_point last_refill_;
    std::mutex mtx_;

    void refill_locked(std::chrono::steady_clock::time_point now) {
        using namespace std::chrono;
        const double dt = duration<double>(now - last_refill_).count(); // 秒
        if (dt > 0) {
            tokens_ = std::min(capacity_, tokens_ + rate_per_sec_ * dt);
            last_refill_ = now;
        }
    }

public:
    TokenBucket(double capacity, double rate_per_sec)
        : capacity_(capacity), rate_per_sec_(rate_per_sec),
          tokens_(capacity), last_refill_(std::chrono::steady_clock::now()) {}

    // 嘗試取得 n 個 token，成功回 true；失敗回 false（不阻塞）
    bool try_acquire(int n = 1) {
        auto now = std::chrono::steady_clock::now();
        std::lock_guard<std::mutex> lk(mtx_);
        refill_locked(now);
        if (tokens_ + 1e-9 >= n) { // 容忍微小浮點誤差
            tokens_ -= n;
            return true;
        }
        return false;
    }

    // 觀察：目前 token 大約多少（僅供監控）
    double approx_tokens() {
        auto now = std::chrono::steady_clock::now();
        std::lock_guard<std::mutex> lk(mtx_);
        refill_locked(now);
        return tokens_;
    }
};
```

> 面試延伸：
>
> 1. 用「整數微單位」避免浮點誤差（例如把 1 token = 1000 micro-tokens）。
> 2. 阻塞版 `acquire(n)` 可用 `condition_variable` 喚醒。
> 3. 在 ISR/MCU：更新 `tokens_` 前後 **disable/enable IRQ** 代替 mutex。

---

# 2) FIFO Circular Queue（array + head/tail 指標）

**心法**

* 使用固定大小的陣列 + 兩個索引：`head`（讀）/`tail`（寫）。
* 判斷：`full` 當下一個 tail 會撞上 head；`empty` 當 head==tail。
* 若容量是 2 的冪，可用位元遮罩取代 `%` 取餘數。

## 2.1 單執行緒／單核（教學版，最直觀）

```cpp
#include <array>
#include <cstddef>
#include <cstdint>

template <typename T, std::size_t N>
class RingBuffer {
    static_assert(N > 1, "N must be > 1");
    std::array<T, N> buf_{};
    std::size_t head_ = 0; // 讀
    std::size_t tail_ = 0; // 寫

    std::size_t inc(std::size_t x) const { return (x + 1) % N; }

public:
    bool empty() const { return head_ == tail_; }
    bool full()  const { return inc(tail_) == head_; }
    std::size_t size() const { return (tail_ + N - head_) % N; }
    std::size_t capacity() const { return N - 1; } // 預留一格區分滿/空

    bool push(const T& v) {
        if (full()) return false;
        buf_[tail_] = v;
        tail_ = inc(tail_);
        return true;
    }

    bool pop(T& out) {
        if (empty()) return false;
        out = buf_[head_];
        head_ = inc(head_);
        return true;
    }
};
```

## 2.2 SPSC（Single-Producer/Single-Consumer）版（鎖免、常見於 UART）

```cpp
#include <array>
#include <atomic>
#include <cstddef>

template <typename T, std::size_t N>
class RingSPSC {
    static_assert((N & (N - 1)) == 0, "N must be power-of-two");
    std::array<T, N> buf_{};
    std::atomic<std::size_t> head_{0}; // 只有 consumer 更新
    std::atomic<std::size_t> tail_{0}; // 只有 producer 更新
    static constexpr std::size_t mask_ = N - 1;

public:
    bool empty() const { return head_.load(std::memory_order_acquire) == tail_.load(std::memory_order_acquire); }
    bool full()  const { return ((tail_.load(std::memory_order_acquire) + 1) & mask_) == head_.load(std::memory_order_acquire); }

    bool push(const T& v) { // producer 線程
        auto t = tail_.load(std::memory_order_relaxed);
        auto h = head_.load(std::memory_order_acquire);
        if (((t + 1) & mask_) == h) return false; // full
        buf_[t & mask_] = v;
        tail_.store((t + 1) & mask_, std::memory_order_release);
        return true;
    }

    bool pop(T& out) { // consumer 線程
        auto h = head_.load(std::memory_order_relaxed);
        auto t = tail_.load(std::memory_order_acquire);
        if (h == t) return false; // empty
        out = buf_[h & mask_];
        head_.store((h + 1) & mask_, std::memory_order_release);
        return true;
    }
};
```

> MCU 對應：UART RX ISR 往環形佇列 `push`，主循環在非中斷情境 `pop`。
> 在 ISR 中「更新 head/tail」的那段即是 **critical section**，常見做法是 **短暫關中斷**。

---

# 3) 系統設計題：設計「簡單 Rate Limiter」（Token Bucket）

**一分鐘口條**

> 我用 **Token Bucket**。每個 key（user/API/IP）維護 `capacity/rate/tokens/last_ts`。
> 本地執行緒先做 **本地桶** 快速判斷；需要全域一致性時，再把計數落到共享存儲（如 Redis/自家服務），以 **1 秒或 100ms 粒度**合併上報，避免熱點。支援 **限流等級、突發（burst）**，以及 **429 + Retry-After** 回應策略。

**設計要點**

* **資料模型**：
  `state = {capacity, rate, tokens, last_ts}`（可加 `burst`, `max_delay`）。
* **補桶策略**：

  * pull-based：請求到來時計算 `dt` 補桶（最簡單）。
  * push-based：背景 timer 每 100ms/1s 補一次（更穩定，便於觀察）。
* **部署拓撲**：

  * 單機：in-proc map（最快）。
  * 分散式：

    * **Local fast-path + global reconcile**（建議）：本機先判定，週期上報。
    * 純集中式（Redis/Limiter 服務）：一致性好但延遲/成本高。
* **精度/抖動**：

  * `timer tick` 越小越平滑（100ms 常見），但心跳成本更高。
* **公平性**：

  * 每 key 獨立桶，或分層（tenant → ip → user）。
* **回應**：

  * 超量 → 429，給 `Retry-After` 或 `X-RateLimit-Remaining/Reset`。
* **I/O block / IRQ 關聯**：

  * 在核心/驅動情境，補桶/扣桶是臨界區，需要 **disable IRQ** 或用鎖；
  * 在使用者態服務，用 `mutex/atomic` 保護即可。
* **監控**：拒絕率、突發長度、bucket 利用率、p95 授權延遲。

---

# 4) 簡易分散式 Log Storage（設計框架）

**目標**

* 高吞吐 append-only 寫入、按 topic/partition 存放、可設定保留/壓縮、故障不丟資料。

**關鍵元件**

1. **Brokers / Ingest**：接收寫入，按 key 做 **partition（consistent hashing）**。
2. **Storage Nodes**：每個 partition 是一條 **append-only segment log**（檔案切段），配 **稀疏索引**（offset→filepos）。
3. **Metadata Service（強一致）**：Topic/Partition/ISR 列表、mapping、lease。

  * 用 **Raft** 或 etcd/ZK；**Leader election** 管理 partition 的 leader。
4. **Replicas**：`replication factor = 3` 常見；寫入路徑 `leader → followers`。

  * **ACK 等級**：`acks=1`（leader 落盤）／`acks=all`（ISR 都收）。
5. **Retention/Compaction**：

  * 時間/容量保留（例如 7 天或 500GB），segment 達閾值輪轉；
  * key-based compaction 保留最新版本（類似 Kafka log compaction）。

**寫入 I/O 路徑（概念）**
App → Broker（batch 聚合） → OS page cache → `append segment` → 週期 `fsync`（或 `O_DIRECT` 視場景）

* **批次 + 順序寫入** 充分利用 SSD/HDD。
* 後台做 **segment 合併/刪舊**，避免隨機寫。

**容錯與恢復**

* 失去 leader → Metadata 觸發重新選舉；client 透過 metadata 重新路由。
* follower 落後 → 根據高水位（HW）追上；超過追趕窗口 → 重新快照。

**與「計算機組織 / I/O block / BSP」的對應**

* **計算機組織**：善用「順序寫 + page cache + 大 block」，減少 seek。
* **I/O block**：segment/索引以 **塊對齊**（4KB/16KB）提升吞吐。
* **BSP**：在邊緣/設備端，driver/文件系統層提供塊設備抽象；雲端側對應為 storage driver/FS/RAID 層。

**面試口條（30 秒）**

> 我用 **topic/partition** 架構；每個 partition 是 append-only 段檔 + 稀疏索引。
> **Metadata（Raft）** 管 leader/副本；寫入走 leader，同步到 ISR。
> 以 **順序寫 + 批次** 取高吞吐，週期 fsync；保留與壓縮用 segment 輪轉與 compaction。
> 失敗切換靠選舉與高水位恢復；路由靠 metadata 映射。

---

## 建議練法（今天就能動手）

* **Coding**：把 `TokenBucket` 包一層 `RateLimiter`，提供 `allow(user_id, n)`；用多執行緒壓測（`std::thread`）看拒絕率。
* **FIFO**：把 `RingSPSC<uint8_t, 256>` 連同一個「模擬 UART ISR：每 1ms push」與「主循環：poll pop」做成 demo。
* **系統設計**：口述一版「單機 → 多機 → 跨機房」演進，準備一張 5×5 取捨表（延遲、吞吐、一致性、成本、工程複雜度）。
* **Log Storage**：畫出 5 個方塊（Client/Broker/Storage/Metadata/Monitor），在紙上標出寫入路徑與失敗切換時序。

如果你要，我可以把上述兩個 C++ 題（TokenBucket、RingSPSC）打包成**單一檔案**、加上簡短 `main()` 測試模板，符合你 CLion 的習慣（含註解）。
